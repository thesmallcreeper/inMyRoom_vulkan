#version 460

#extension GL_EXT_nonuniform_qualifier : require
#extension GL_EXT_shader_16bit_storage : require

#include "common/structs/ModelMatrices.h"

#ifdef USE_VEC2
    #define VEC vec2
#else
    #define VEC vec4
#endif

layout(local_size_x = LOCAL_SIZE_X, local_size_y = 1, local_size_z = 1) in;

// Push constant

layout (push_constant) uniform PushConstants
{
    layout(offset = 0)  uint matrixOffset;
    layout(offset = 4)  uint inverseMatricesOffset;
    layout(offset = 8)  uint verticesOffset;
    layout(offset = 12) uint jointsOffset;
    layout(offset = 16) uint weightsOffset;
    layout(offset = 20) uint jointsGroupsCount;
    layout(offset = 24) uint morphTargets;
    layout(offset = 28) uint size_x;
    layout(offset = 32) uint step_multiplier;
    layout(offset = 36) uint resultDescriptorIndex;
    layout(offset = 40) uint resultOffset;
    layout(offset = 44) float morph_weights[MAX_MORPH_WEIGHTS];
};

// Description sets

layout( std140, set = 0 , binding = 0 ) readonly buffer nodesMatrixBuffer
{
    ModelMatrices modelMatrices[MATRICES_COUNT];
};

layout( std140, set = 1 , binding = 0 ) readonly buffer inverseMatricesBuffer
{
    ModelMatrices inverseModelMatrices[INVERSE_MATRICES_COUNT];
};

layout( std430, set = 2, binding = 0 ) buffer vecVerticesBuffersDescriptors
{
    VEC vertices[];
} verticesBuffers [];

layout( std430, set = 2, binding = 0 ) buffer uvec4verticesBuffersDescriptors
{
    u16vec4 vertices[];
} u16vec4verticesBuffers [];

layout( std430, set = 2, binding = 0 ) buffer vec4verticesBuffersDescriptors
{
    vec4 vertices[];
} vec4verticesBuffers [];

vec4 CalucateSkinJoint(uint matrix_index, uint inverse_matrix_index, vec4 vertex)
{
    vec4 return_vec;

    #ifndef USE_NORMAL_MATRIX
    #ifndef ZERO_W
    return_vec = modelMatrices[matrix_index].positionMatrix * inverseModelMatrices[inverse_matrix_index].positionMatrix * vertex;
    #else
    return_vec = modelMatrices[matrix_index].positionMatrix * inverseModelMatrices[inverse_matrix_index].positionMatrix * vec4(vertex.xyz, 0.f);
    #endif
    #else
    return_vec = modelMatrices[matrix_index].normalMatrix * inverseModelMatrices[inverse_matrix_index].normalMatrix * vec4(vertex.xyz, 0.f);
    #endif

    #ifdef NORMALIZE
    return_vec = vec4(normalize(return_vec.xyz), vertex.w);
    #endif

    return return_vec;
}

void main()
{
    const uint x = gl_GlobalInvocationID.x;
    if (x >= size_x) {
        return;
    }

    VEC morphed_vertex = verticesBuffers[0].vertices[verticesOffset + (morphTargets + 1) * x * step_multiplier];
    for (uint i = 0; i != morphTargets && i != MAX_MORPH_WEIGHTS; ++i) {
        VEC this_vertex = verticesBuffers[0].vertices[verticesOffset + (morphTargets + 1) * x * step_multiplier + (i + 1)];
        float this_weight = morph_weights[i];

        morphed_vertex += this_weight * this_vertex;
    }

    #ifdef NORMALIZE
    if (morphTargets != 0) {
        morphed_vertex = vec4(normalize(morphed_vertex.xyz), morphed_vertex.w);
    }
    #endif

    #ifdef USE_SKIN
    vec4 result = vec4(0.f, 0.f, 0.f, 0.f);
    if (jointsGroupsCount == 0) {
        result = morphed_vertex;
    }
    for (uint i = 0; i != jointsGroupsCount; ++i) {
        vec4 weights = vec4verticesBuffers[0].vertices[weightsOffset  + x*jointsGroupsCount + i];
        uvec4 joints = uvec4(u16vec4verticesBuffers[0].vertices[jointsOffset + x*jointsGroupsCount + i]);

        result += weights.x * CalucateSkinJoint( joints.x+matrixOffset+1, joints.x+inverseMatricesOffset, morphed_vertex);
        result += weights.y * CalucateSkinJoint( joints.y+matrixOffset+1, joints.y+inverseMatricesOffset, morphed_vertex);
        result += weights.z * CalucateSkinJoint( joints.z+matrixOffset+1, joints.z+inverseMatricesOffset, morphed_vertex);
        result += weights.w * CalucateSkinJoint( joints.w+matrixOffset+1, joints.w+inverseMatricesOffset, morphed_vertex);
    }

    #ifdef NORMALIZE
    if (jointsGroupsCount != 0) {
        morphed_vertex = vec4(normalize(result.xyz), result.w);
    }
    #endif

    #else
    VEC result = morphed_vertex;
    #endif

    verticesBuffers[resultDescriptorIndex].vertices[resultOffset + x * step_multiplier] = result;
}

